/*
 * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _stream = require('stream');

var _stream2 = _interopRequireDefault(_stream);

var _through2 = require('through2');

var _through22 = _interopRequireDefault(_through2);

var _blockStream2 = require('block-stream2');

var _blockStream22 = _interopRequireDefault(_blockStream2);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _xml = require('xml');

var _xml2 = _interopRequireDefault(_xml);

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _async = require('async');

var _async2 = _interopRequireDefault(_async);

var _helpersJs = require('./helpers.js');

var _multipartJs = require('./multipart.js');

var _multipartJs2 = _interopRequireDefault(_multipartJs);

var _signingJs = require('./signing.js');

var _transformers = require('./transformers');

var transformers = _interopRequireWildcard(_transformers);

var _errorsJs = require('./errors.js');

var _errorsJs2 = _interopRequireDefault(_errorsJs);

require('source-map-support').install();

var Package = require('../../package.json');

var Client = (function (_Multipart) {
  _inherits(Client, _Multipart);

  function Client(params, transport) {
    _classCallCheck(this, Client);

    var namespace = 'Minio';
    var parsedUrl = _url2['default'].parse(params.url),
        port = +parsedUrl.port;

    var host = parsedUrl.hostname;
    var protocol = '';

    if (!transport) {
      switch (parsedUrl.protocol) {
        case 'http:':
          {
            transport = _http2['default'];
            protocol = 'http:';
            if (port === 0) {
              port = 80;
            }
            break;
          }
        case 'https:':
          {
            transport = _https2['default'];
            protocol = 'https:';
            if (port === 0) {
              port = 443;
            }
            break;
          }
        default:
          {
            throw new _errorsJs2['default'].InvalidProtocolException('Unknown protocol: ' + parsedUrl.protocol);
          }
      }
    }
    var newParams = {
      host: host,
      port: port,
      protocol: protocol,
      accessKey: params.accessKey,
      secretKey: params.secretKey,
      userAgent: 'minio-js/' + Package.version + ' (' + process.platform + '; ' + process.arch + ')',
      userAgentSet: false
    };
    _get(Object.getPrototypeOf(Client.prototype), 'constructor', this).call(this, newParams, transport);
    this.params = newParams;
    this.transport = transport;
  }

  // Build PostPolicy object that can be signed by presignedPostPolicy

  // CLIENT LEVEL CALLS

  _createClass(Client, [{
    key: 'setUserAgent',
    value: function setUserAgent(name, version, comments) {
      var formattedComments = '';
      if (comments && comments.length > 0) {
        var joinedComments = comments.join('; ');
        formattedComments = ' (' + joinedComments + ')';
      }
      if (this.params.userAgentSet) {
        throw new _errorsJs2['default'].InternalClientException('user agent already set');
      }
      if (name && version) {
        this.params.userAgent = this.params.userAgent + ' ' + name + '/' + version + formattedComments;
        this.params.userAgentSet = true;
      } else {
        throw new _errorsJs2['default'].InvalidUserAgentException('Invalid user agent');
      }
    }

    // SERVICE LEVEL CALLS

  }, {
    key: 'bucketRequest',
    value: function bucketRequest(method, bucket, cb) {
      var path = '/' + bucket;
      this.request(method, path, cb);
    }
  }, {
    key: 'objectRequest',
    value: function objectRequest(method, bucket, object, cb) {
      var path = '/' + bucket + '/' + (0, _helpersJs.uriResourceEscape)(object);
      this.request(method, path, cb);
    }
  }, {
    key: 'request',
    value: function request(method, path, cb) {
      var requestParams = {
        host: this.params.host,
        port: this.params.port,
        protocol: this.params.protocol,
        method: method,
        path: path
      };

      (0, _signingJs.signV4)(requestParams, '', this.params.accessKey, this.params.secretKey);

      var req = this.transport.request(requestParams, function (response) {
        if (response.statusCode >= 300) {
          var concater = transformers.getConcater();
          var errorTransformer = transformers.getErrorTransformer(response);
          (0, _helpersJs.pipesetup)(response, concater, errorTransformer).on('error', function (e) {
            return cb(e);
          });
          return;
        }
        // no data expected
        cb();
      });
      req.on('error', function (e) {
        return cb(e);
      });
      req.end();
    }

    // Creates the bucket `bucketName`.
    //
    // __Arguments__
    // * `bucketName` _string_ - Name of the bucket
    // * `callback(err)` _function_ - callback function with `err` as the error argument. `err` is null if the bucket is successfully created.
  }, {
    key: 'makeBucket',
    value: function makeBucket(bucket, cb) {
      return this.makeBucketWithACL(bucket, 'private', cb);
    }
  }, {
    key: 'makeBucketWithACL',
    value: function makeBucketWithACL(bucket, acl, cb) {
      if (!(0, _helpersJs.validateBucketName)(bucket)) {
        throw new _errorsJs2['default'].InvalidateBucketNameException('Invalid bucket name: ' + bucket);
      }

      var region = (0, _helpersJs.getRegion)(this.params.host);
      if (region === 'us-east-1') {
        region = null;
      }
      var payload = '';
      if (region) {
        var createBucketConfiguration = [];
        createBucketConfiguration.push({
          _attr: {
            xmlns: 'http://s3.amazonaws.com/doc/2006-03-01/'
          }
        });
        createBucketConfiguration.push({
          LocationConstraint: region
        });
        var payloadObject = {
          CreateBucketConfiguration: createBucketConfiguration
        };
        payload = (0, _xml2['default'])(payloadObject);
      }

      var hash = _crypto2['default'].createHash('sha256');
      hash.update(payload);
      var sha256 = hash.digest('hex').toLowerCase(),
          requestParams = {
        host: this.params.host,
        port: this.params.port,
        protocol: this.params.protocol,
        method: 'PUT',
        path: '/' + bucket,
        headers: {
          'Content-Length': payload.length,
          'x-amz-acl': acl
        }
      };

      (0, _signingJs.signV4)(requestParams, sha256, this.params.accessKey, this.params.secretKey);

      var req = this.transport.request(requestParams, function (response) {
        if (response.statusCode !== 200) {
          var errorTransformer = transformers.getErrorTransformer(response, true);
          var concater = transformers.getConcater();
          (0, _helpersJs.pipesetup)(response, concater, errorTransformer).on('error', function (e) {
            return cb(e);
          });
          return;
        }
        cb();
      });
      req.write(payload);
      req.end();
    }

    // List of buckets created.
    //
    // __Arguments__
    // * `callback(err, bucketStream)` _function_ - callback function with error as the first argument. `bucketStream` is the stream emitting bucket information.
    //
    // `bucketStream` emits Object with the format:
    // * `obj.name` _string_ : bucket name
    // * `obj.creationDate` _string_: date when bucket was created
  }, {
    key: 'listBuckets',
    value: function listBuckets(cb) {
      var requestParams = {
        host: this.params.host,
        port: this.params.port,
        protocol: this.params.protocol,
        path: '/',
        method: 'GET'
      };

      (0, _signingJs.signV4)(requestParams, '', this.params.accessKey, this.params.secretKey);

      var concater = transformers.getConcater();

      var req = this.transport.request(requestParams, function (response) {
        if (response.statusCode !== 200) {
          var errorTransformer = transformers.getErrorTransformer(response, true);
          (0, _helpersJs.pipesetup)(response, concater, errorTransformer).on('error', function (e) {
            return cb(e);
          });
          return;
        }
        var transformer = transformers.getListBucketTransformer();
        (0, _helpersJs.pipesetup)(response, concater, transformer);
        cb(null, transformer);
      });
      req.on('error', function (e) {
        return cb(e);
      });
      req.end();
    }

    // Returns a stream that emits objects that are partially uploaded.
    //
    // __Arguments__
    // * `bucketname` _string_: name of the bucket
    // * `prefix` _string_: prefix of the object names that are partially uploaded
    // * `recursive` bool: directory style listing when false, recursive listing when true
    //
    // __Return Value__
    // * `stream` _Stream_ : emits objects of the format:
    //   * `object.key` _string_: name of the object
    //   * `object.uploadId` _string_: upload ID of the object
    //   * `object.size` _Integer_: size of the partially uploaded object
  }, {
    key: 'listIncompleteUploads',
    value: function listIncompleteUploads(bucket, prefix, recursive) {
      if (!(0, _helpersJs.validateBucketName)(bucket)) {
        throw new _errorsJs2['default'].InvalidateBucketNameException('Invalid bucket name: ' + bucket);
      }
      var delimiter = recursive ? null : "/";
      var dummyTransformer = transformers.getDummyTransformer();
      var self = this;
      function listNext(keyMarker, uploadIdMarker) {
        self.listIncompleteUploadsOnce(bucket, prefix, keyMarker, uploadIdMarker, delimiter).on('error', function (e) {
          return dummyTransformer.emit('error', e);
        }).on('data', function (result) {
          result.prefixes.forEach(function (prefix) {
            return dummyTransformer.write(prefix);
          });
          _async2['default'].eachSeries(result.uploads, function (upload, cb) {
            self.listAllParts(bucket, upload.key, upload.uploadId, function (err, parts) {
              if (err) return cb(err);
              upload.size = parts.reduce(function (acc, item) {
                return acc + item.size;
              }, 0);
              dummyTransformer.write(upload);
              cb();
            });
          }, function (err) {
            if (err) {
              dummyTransformer.emit('error', e);
              dummyTransformer.end();
              return;
            }
            if (result.isTruncated) {
              listNext(result.nextKeyMarker, result.nextUploadIdMarker);
              return;
            }
            dummyTransformer.end(); // signal 'end'
          });
        });
      }
      listNext();
      return dummyTransformer;
    }

    // To check if a bucket already exists.
    //
    // __Arguments__
    // * `bucketName` _string_ : name of the bucket
    // * `callback(err)` _function_ : `err` is `null` if the bucket exists
  }, {
    key: 'bucketExists',
    value: function bucketExists(bucket, cb) {
      if (!(0, _helpersJs.validateBucketName)(bucket)) {
        throw new _errorsJs2['default'].InvalidateBucketNameException('Invalid bucket name: ' + bucket);
      }
      this.bucketRequest('HEAD', bucket, cb);
    }

    // Remove a bucket.
    //
    // __Arguments__
    // * `bucketName` _string_ : name of the bucket
    // * `callback(err)` _function_ : `err` is `null` if the bucket is removed successfully.
  }, {
    key: 'removeBucket',
    value: function removeBucket(bucket, cb) {
      if (!(0, _helpersJs.validateBucketName)(bucket)) {
        throw new _errorsJs2['default'].InvalidateBucketNameException('Invalid bucket name: ' + bucket);
      }
      this.bucketRequest('DELETE', bucket, cb);
    }

    // get a bucket's ACL.
    //
    // __Arguments__
    // * `bucketName` _string_ : name of the bucket
    // * `callback(err, acl)` _function_ : `err` is not `null` in case of error. `acl` _string_ is the cannedACL which can have the values _private_, _public-read_, _public-read-write_.
  }, {
    key: 'getBucketACL',
    value: function getBucketACL(bucket, cb) {
      if (!(0, _helpersJs.validateBucketName)(bucket)) {
        throw new _errorsJs2['default'].InvalidateBucketNameException('Invalid bucket name: ' + bucket);
      }

      var query = '?acl',
          requestParams = {
        host: this.params.host,
        port: this.params.port,
        protocol: this.params.protocol,
        method: 'GET',
        path: '/' + bucket + query
      };

      (0, _signingJs.signV4)(requestParams, '', this.params.accessKey, this.params.secretKey);
      var req = this.transport.request(requestParams, function (response) {
        var concater = transformers.getConcater();
        var errorTransformer = transformers.getErrorTransformer(response);
        var transformer = transformers.getAclTransformer();
        if (response.statusCode !== 200) {
          (0, _helpersJs.pipesetup)(response, concater, errorTransformer).on('error', function (e) {
            return cb(e);
          });
          return;
        }
        (0, _helpersJs.pipesetup)(response, concater, transformer).on('error', function (e) {
          return cb(e);
        }).on('data', function (data) {
          var perm = data.acl.reduce(function (acc, grant) {
            if (grant.grantee.uri === 'http://acs.amazonaws.com/groups/global/AllUsers') {
              if (grant.permission === 'READ') {
                acc.publicRead = true;
              } else if (grant.permission === 'WRITE') {
                acc.publicWrite = true;
              }
            } else if (grant.grantee.uri === 'http://acs.amazonaws.com/groups/global/AuthenticatedUsers') {
              if (grant.permission === 'READ') {
                acc.authenticatedRead = true;
              } else if (grant.permission === 'WRITE') {
                acc.authenticatedWrite = true;
              }
            }
            return acc;
          }, {});
          var cannedACL = 'unsupported-acl';
          if (perm.publicRead && perm.publicWrite && !perm.authenticatedRead && !perm.authenticatedWrite) {
            cannedACL = 'public-read-write';
          } else if (perm.publicRead && !perm.publicWrite && !perm.authenticatedRead && !perm.authenticatedWrite) {
            cannedACL = 'public-read';
          } else if (!perm.publicRead && !perm.publicWrite && perm.authenticatedRead && !perm.authenticatedWrite) {
            cannedACL = 'authenticated-read';
          } else if (!perm.publicRead && !perm.publicWrite && !perm.authenticatedRead && !perm.authenticatedWrite) {
            cannedACL = 'private';
          }
          cb(null, cannedACL);
        });
      });
      req.on('error', function (e) {
        return cb(e);
      });
      req.end();
    }

    // set a bucket's ACL.
    //
    // __Arguments__
    // * `bucketName` _string_: name of the bucket
    // * `acl` _string_: acl can be _private_, _public-read_, _public-read-write_
    // * `callback(err)` _function_: callback is called with error or `null`
  }, {
    key: 'setBucketACL',
    value: function setBucketACL(bucket, acl, cb) {
      if (!(0, _helpersJs.validateBucketName)(bucket)) {
        throw new _errorsJs2['default'].InvalidateBucketNameException('Invalid bucket name: ' + bucket);
      }

      if (acl === null || acl.trim() === '') {
        throw new _errorsJs2['default'].InvalidEmptyACLException('Acl name cannot be empty');
      }

      // we should make sure to set this query parameter, but on the other hand
      // the call apparently succeeds without it to s3.  For clarity lets do it anyways
      var query = '?acl',
          requestParams = {
        host: this.params.host,
        port: this.params.port,
        protocol: this.params.protocol,
        method: 'PUT',
        path: '/' + bucket + query,
        headers: {
          'x-amz-acl': acl
        }
      };

      (0, _signingJs.signV4)(requestParams, '', this.params.accessKey, this.params.secretKey);

      var req = this.transport.request(requestParams, function (response) {
        var concater = transformers.getConcater();
        var errorTransformer = transformers.getErrorTransformer(response);
        if (response.statusCode !== 200) {
          (0, _helpersJs.pipesetup)(response, concater, errorTransformer).on('error', function (e) {
            return cb(e);
          });
          return;
        }
        cb();
      });
      // FIXME: the below line causes weird failure in 'gulp test'
      // req.on('error', e => cb(e))
      req.end();
    }

    // Remove the partially uploaded object.
    //
    // __Arguments__
    // * `bucketName` _string_: name of the bucket
    // * `objectName` _string_: name of the object
    // * `callback(err)` _function_: callback function is called with non `null` value in case of error
  }, {
    key: 'removeIncompleteUpload',
    value: function removeIncompleteUpload(bucketName, objectName, cb) {
      if (!(0, _helpersJs.validateBucketName)(bucketName)) {
        throw new _errorsJs2['default'].InvalidateBucketNameException('Invalid bucket name: ' + bucket);
      }

      if (objectName === null || objectName.trim() === '') {
        throw new _errorsJs2['default'].InvalidObjectNameException('Object name cannot be empty');
      }

      var self = this;
      this.findUploadId(bucketName, objectName, function (err, uploadId) {
        if (err || !uploadId) {
          return cb(err);
        }
        var requestParams = {
          host: self.params.host,
          port: self.params.port,
          protocol: self.params.protocol,
          path: '/' + bucketName + '/' + objectName + '?uploadId=' + uploadId,
          method: 'DELETE'
        };

        (0, _signingJs.signV4)(requestParams, '', self.params.accessKey, self.params.secretKey);

        var req = self.transport.request(requestParams, function (response) {
          if (response.statusCode !== 204) {
            var concater = transformers.getConcater();
            var errorTransformer = transformers.getErrorTransformer(response);
            (0, _helpersJs.pipesetup)(response, concater, errorTransformer).on('error', function (e) {
              return cb(e);
            });
            return;
          }
          cb();
        });
        req.on('error', function (e) {
          return cb(e);
        });
        req.end();
      });
    }

    // Callback is called with readable stream of the object content.
    //
    // __Arguments__
    // * `bucketName` _string_: name of the bucket
    // * `objectName` _string_: name of the object
    // * `callback(err, stream)` _function_: callback is called with `err` in case of error. `stream` is the object content stream
  }, {
    key: 'getObject',
    value: function getObject(bucketName, objectName, cb) {
      if (!(0, _helpersJs.validateBucketName)(bucketName)) {
        throw new _errorsJs2['default'].InvalidateBucketNameException('Invalid bucket name: ' + bucketName);
      }

      if (objectName === null || objectName.trim() === '') {
        throw new _errorsJs2['default'].InvalidObjectNameException('Object name cannot be empty');
      }
      this.getPartialObject(bucketName, objectName, 0, 0, cb);
    }

    // Callback is called with readable stream of the partial object content.
    //
    // __Arguments__
    // * `bucketName` _string_: name of the bucket
    // * `objectName` _string_: name of the object
    // * `offset` _number_: offset of the object from where the stream will start
    // * `length` _number_: length of the object that will be read in the stream
    // * `callback(err, stream)` _function_: callback is called with `err` in case of error. `stream` is the object content stream
  }, {
    key: 'getPartialObject',
    value: function getPartialObject(bucketName, objectName, offset, length, cb) {
      if (!(0, _helpersJs.validateBucketName)(bucketName)) {
        throw new _errorsJs2['default'].InvalidateBucketNameException('Invalid bucket name: ' + bucketName);
      }

      if (objectName === null || objectName.trim() === '') {
        throw new _errorsJs2['default'].InvalidObjectNameException('Object name cannot be empty');
      }

      var range = '';
      if (offset || length) {
        if (offset) {
          range = 'bytes=' + +offset + '-';
        } else {
          range = 'bytes=0-';
          offset = 0;
        }
        if (length) {
          range += '' + (+length + offset - 1);
        }
      }

      var headers = {};
      if (range !== '') {
        headers.Range = range;
      }

      var requestParams = {
        host: this.params.host,
        port: this.params.port,
        protocol: this.params.protocol,
        path: '/' + bucketName + '/' + (0, _helpersJs.uriResourceEscape)(objectName),
        method: 'GET',
        headers: headers
      };

      (0, _signingJs.signV4)(requestParams, '', this.params.accessKey, this.params.secretKey);

      var req = this.transport.request(requestParams, function (response) {
        if (!(response.statusCode === 200 || response.statusCode === 206)) {
          var concater = transformers.getConcater();
          var errorTransformer = transformers.getErrorTransformer(response);
          (0, _helpersJs.pipesetup)(response, concater, errorTransformer).on('error', function (e) {
            return cb(e);
          });
          return;
        }
        var dummyTransformer = transformers.getDummyTransformer();
        (0, _helpersJs.pipesetup)(response, dummyTransformer);
        cb(null, dummyTransformer);
        return;
      });
      req.on('error', function (e) {
        return cb(e);
      });
      req.end();
    }

    // Uploads the object.
    //
    // __Arguments__
    // * `bucketName` _string_: name of the bucket
    // * `objectName` _string_: name of the object
    // * `contentType` _string_: content type of the object
    // * `size` _number_: size of the object
    // * `stream` _Stream_: Readable stream
    // * `callback(err, etag)` _function_: non null `err` indicates error, `etag` _string_ is the etag of the object uploaded.
  }, {
    key: 'putObject',
    value: function putObject(bucketName, objectName, contentType, size, r, cb) {
      if (!(0, _helpersJs.validateBucketName)(bucketName)) {
        throw new _errorsJs2['default'].InvalidateBucketNameException('Invalid bucket name: ' + bucketName);
      }

      if (objectName === null || objectName.trim() === '') {
        throw new _errorsJs2['default'].InvalidObjectNameException('Object name cannot be empty');
      }

      if (contentType === null || contentType.trim() === '') {
        contentType = 'application/octet-stream';
      }

      function calculatePartSize(size) {
        var minimumPartSize = 5 * 1024 * 1024,
            // 5MB
        maximumPartSize = 5 * 1025 * 1024 * 1024,

        // using 10000 may cause part size to become too small, and not fit the entire object in
        partSize = Math.floor(size / 9999);

        if (partSize > maximumPartSize) {
          return maximumPartSize;
        }
        return Math.max(minimumPartSize, partSize);
      }

      var self = this;
      if (size <= 5 * 1024 * 1024) {
        var concater = transformers.getConcater();
        (0, _helpersJs.pipesetup)(r, concater).on('error', function (e) {
          return cb(e);
        }).on('data', function (chunk) {
          return self.doPutObject(bucketName, objectName, contentType, null, null, chunk, cb);
        });
        return;
      }
      _async2['default'].waterfall([function (cb) {
        self.findUploadId(bucketName, objectName, cb);
      }, function (uploadId, cb) {
        if (uploadId) {
          self.listAllParts(bucketName, objectName, uploadId, function (e, etags) {
            return cb(e, uploadId, etags);
          });
          return;
        }
        self.initiateNewMultipartUpload(bucketName, objectName, contentType, function (e, uploadId) {
          return cb(e, uploadId, []);
        });
      }, function (uploadId, etags, cb) {
        var partSize = calculatePartSize(size);
        var sizeVerifier = transformers.getSizeVerifierTransformer(size);
        var chunker = (0, _blockStream22['default'])({ size: partSize, zeroPadding: false });
        var chunkUploader = self.chunkUploader(bucketName, objectName, contentType, uploadId, etags);
        (0, _helpersJs.pipesetup)(r, chunker, sizeVerifier, chunkUploader).on('error', function (e) {
          return cb(e);
        }).on('data', function (etags) {
          return cb(null, etags, uploadId);
        });
      }, function (etags, uploadId, cb) {
        self.completeMultipartUpload(bucketName, objectName, uploadId, etags, cb);
      }], function (err, etag) {
        if (err) {
          return cb(err);
        }
        cb(null, etag);
      });
    }
  }, {
    key: 'listObjectsOnce',
    value: function listObjectsOnce(bucket, prefix, marker, delimiter, maxKeys) {
      var queries = [];
      // escape every value in query string, except maxKeys
      if (prefix) {
        prefix = (0, _helpersJs.uriEscape)(prefix);
        queries.push('prefix=' + prefix);
      }
      if (marker) {
        marker = (0, _helpersJs.uriEscape)(marker);
        queries.push('marker=' + marker);
      }
      if (delimiter) {
        delimiter = (0, _helpersJs.uriEscape)(delimiter);
        queries.push('delimiter=' + delimiter);
      }
      // no need to escape maxKeys
      if (maxKeys) {
        if (maxKeys >= 1000) {
          maxKeys = 1000;
        }
        queries.push('max-keys=' + maxKeys);
      }
      queries.sort();
      var query = '';
      if (queries.length > 0) {
        query = '?' + queries.join('&');
      }
      var requestParams = {
        host: this.params.host,
        port: this.params.port,
        protocol: this.params.protocol,
        path: '/' + bucket + query,
        method: 'GET'
      };

      var dummyTransformer = transformers.getDummyTransformer();
      (0, _signingJs.signV4)(requestParams, '', this.params.accessKey, this.params.secretKey);

      var req = this.transport.request(requestParams, function (response) {
        var errorTransformer = transformers.getErrorTransformer(response);
        var concater = transformers.getConcater();
        var transformer = transformers.getListObjectsTransformer();
        if (response.statusCode !== 200) {
          (0, _helpersJs.pipesetup)(response, concater, errorTransformer, dummyTransformer);
          return;
        }
        (0, _helpersJs.pipesetup)(response, concater, transformer, dummyTransformer);
      });
      req.end();
      return dummyTransformer;
    }

    // List the objects in the bucket.
    //
    // __Arguments__
    // * `bucketName` _string_: name of the bucket
    // * `prefix` _string_: the prefix of the objects that should be listed
    // * `recursive` _bool_: `true` indicates recursive style listing and `false` indicates directory style listing delimited by '/'.
    //
    // __Return Value__
    // * `stream` _Stream_: stream emitting the objects in the bucket, the object is of the format:
    //   * `stat.key` _string_: name of the object
    //   * `stat.size` _number_: size of the object
    //   * `stat.etag` _string_: etag of the object
    //   * `stat.lastModified` _string_: modified time stamp
  }, {
    key: 'listObjects',
    value: function listObjects(bucketName, prefix, recursive) {
      if (!(0, _helpersJs.validateBucketName)(bucketName)) {
        throw new _errorsJs2['default'].InvalidateBucketNameException('Invalid bucket name: ' + bucketName);
      }
      // recursive is null set delimiter to '/'.
      var delimiter = recursive ? null : "/";
      var dummyTransformer = transformers.getDummyTransformer();
      var self = this;
      function listNext(marker) {
        self.listObjectsOnce(bucketName, prefix, marker, delimiter, 1000).on('error', function (e) {
          return dummyTransformer.emit('error', e);
        }).on('data', function (result) {
          result.objects.forEach(function (object) {
            dummyTransformer.push(object);
          });
          if (result.isTruncated) {
            listNext(result.nextMarker);
            return;
          }
          dummyTransformer.push(null); // signal 'end'
        });
      }
      listNext();
      return dummyTransformer;
    }

    // Stat information of the object.
    //
    // __Arguments__
    // * `bucketName` _string_: name of the bucket
    // * `objectName` _string_: name of the object
    // * `callback(err, stat)` _function_: `err` is not `null` in case of error, `stat` contains the object information:
    //   * `stat.size` _number_: size of the object
    //   * `stat.etag` _string_: etag of the object
    //   * `stat.contentType` _string_: Content-Type of the object
    //   * `stat.lastModified` _string_: modified time stamp
  }, {
    key: 'statObject',
    value: function statObject(bucketName, objectName, cb) {
      if (!(0, _helpersJs.validateBucketName)(bucketName)) {
        throw new _errorsJs2['default'].InvalidateBucketNameException('Invalid bucket name: ' + bucketName);
      }

      if (objectName === null || objectName.trim() === '') {
        throw new _errorsJs2['default'].InvalidObjectNameException('Object name cannot be empty');
      }

      var requestParams = {
        host: this.params.host,
        port: this.params.port,
        protocol: this.params.protocol,
        path: '/' + bucketName + '/' + (0, _helpersJs.uriResourceEscape)(objectName),
        method: 'HEAD'
      };

      (0, _signingJs.signV4)(requestParams, '', this.params.accessKey, this.params.secretKey);

      var req = this.transport.request(requestParams, function (response) {
        var errorTransformer = transformers.getErrorTransformer(response);
        var concater = transformers.getConcater();
        if (response.statusCode !== 200) {
          (0, _helpersJs.pipesetup)(response, concater, errorTransformer).on('error', function (e) {
            return cb(e);
          });
          return;
        }
        var result = {
          size: +response.headers['content-length'],
          etag: response.headers.etag.replace(/"/g, ''),
          contentType: response.headers['content-type'],
          lastModified: response.headers['last-modified']
        };
        cb(null, result);
      });
      req.end();
    }

    // Remove the specified object.
    //
    // __Arguments__
    // * `bucketName` _string_: name of the bucket
    // * `objectName` _string_: name of the object
    // * `callback(err)` _function_: callback function is called with non `null` value in case of error
  }, {
    key: 'removeObject',
    value: function removeObject(bucketName, objectName, cb) {
      if (!(0, _helpersJs.validateBucketName)(bucketName)) {
        throw new _errorsJs2['default'].InvalidateBucketNameException('Invalid bucket name: ' + bucketName);
      }

      if (objectName === null || objectName.trim() === '') {
        throw new _errorsJs2['default'].InvalidObjectNameException('Object name cannot be empty');
      }
      this.objectRequest('DELETE', bucketName, objectName, cb);
    }

    // Generate a presigned URL for PUT. Using this URL, the browser can upload to S3 only with the specified object name.
    //
    // __Arguments__
    // * `bucketName` _string_: name of the bucket
    // * `objectName` _string_: name of the object
    // * `expiry` _number_: expiry in seconds
  }, {
    key: 'presignedPutObject',
    value: function presignedPutObject(bucketName, objectName, expires) {
      if (!(0, _helpersJs.validateBucketName)(bucketName)) {
        throw new _errorsJs2['default'].InvalidateBucketNameException('Invalid bucket name: ' + bucketName);
      }
      if (objectName === null || objectName.trim() === '') {
        throw new _errorsJs2['default'].InvalidObjectNameException('Object name cannot be empty');
      }
      var requestParams = {
        host: this.params.host,
        port: this.params.port,
        protocol: this.params.protocol,
        path: '/' + bucketName + '/' + (0, _helpersJs.uriResourceEscape)(objectName),
        method: 'PUT',
        expires: expires
      };
      return (0, _signingJs.presignSignatureV4)(requestParams, this.params.accessKey, this.params.secretKey);
    }

    // Generate a presigned URL for GET
    //
    // __Arguments__
    // * `bucketName` _string_: name of the bucket
    // * `objectName` _string_: name of the object
    // * `expiry` _number_: expiry in seconds
  }, {
    key: 'presignedGetObject',
    value: function presignedGetObject(bucketName, objectName, expires) {
      if (!(0, _helpersJs.validateBucketName)(bucketName)) {
        throw new _errorsJs2['default'].InvalidateBucketNameException('Invalid bucket name: ' + bucketName);
      }
      if (objectName === null || objectName.trim() === '') {
        throw new _errorsJs2['default'].InvalidObjectNameException('Object name cannot be empty');
      }
      var requestParams = {
        host: this.params.host,
        port: this.params.port,
        protocol: this.params.protocol,
        path: '/' + bucketName + '/' + (0, _helpersJs.uriResourceEscape)(objectName),
        method: 'GET',
        expires: expires
      };
      return (0, _signingJs.presignSignatureV4)(requestParams, this.params.accessKey, this.params.secretKey);
    }

    // return PostPolicy object
  }, {
    key: 'newPostPolicy',
    value: function newPostPolicy() {
      return new PostPolicy();
    }

    // presignedPostPolicy can be used in situations where we want more control on the upload than what
    // presignedPutObject() provides. i.e Using presignedPostPolicy we will be able to put policy restrictions
    // on the object's `name` `bucket` `expiry` `Content-Type`
  }, {
    key: 'presignedPostPolicy',
    value: function presignedPostPolicy(postPolicy) {
      var date = _moment2['default'].utc();
      var region = (0, _helpersJs.getRegion)(this.params.host);
      var dateStr = date.format('YYYYMMDDTHHmmss') + 'Z';

      postPolicy.policy.conditions.push(['eq', '$x-amz-date', dateStr]);
      postPolicy.formData['x-amz-date'] = dateStr;

      postPolicy.policy.conditions.push(['eq', '$x-amz-algorithm', 'AWS4-HMAC-SHA256']);
      postPolicy.formData['x-amz-algorithm'] = 'AWS4-HMAC-SHA256';

      postPolicy.policy.conditions.push(["eq", "$x-amz-credential", this.params.accessKey + "/" + (0, _helpersJs.getScope)(region, date)]);
      postPolicy.formData['x-amz-credential'] = this.params.accessKey + "/" + (0, _helpersJs.getScope)(region, date);

      var policyBase64 = new Buffer(JSON.stringify(postPolicy.policy)).toString('base64');

      postPolicy.formData.policy = policyBase64;

      var signature = (0, _signingJs.postPresignSignatureV4)(region, date, this.params.secretKey, policyBase64);

      postPolicy.formData['x-amz-signature'] = signature;

      return postPolicy.formData;
    }
  }]);

  return Client;
})(_multipartJs2['default']);

exports['default'] = Client;

var PostPolicy = (function () {
  function PostPolicy() {
    _classCallCheck(this, PostPolicy);

    this.policy = {
      conditions: []
    };
    this.formData = {};
  }

  // set expiration date

  _createClass(PostPolicy, [{
    key: 'setExpires',
    value: function setExpires(nativedate) {
      var date = (0, _moment2['default'])(nativedate);
      if (!date) {
        throw new _errorsJs2['default']("date can not be null");
      }

      function getExpirationString(date) {
        return date.format('YYYY-MM-DDThh:mm:ss.SSS') + 'Z';
      }
      this.policy.expiration = getExpirationString(date);
    }

    // set object name
  }, {
    key: 'setKey',
    value: function setKey(key) {
      if (!key) {
        throw new _errorsJs2['default']("key can not be null");
      }
      this.policy.conditions.push(["eq", "$key", key]);
      this.formData.key = key;
    }

    // set object name prefix, i.e policy allows any keys with this prefix
  }, {
    key: 'setKeyStartsWith',
    value: function setKeyStartsWith(prefix) {
      if (!prefix) {
        throw new _errorsJs2['default']("key prefix can not be null");
      }
      this.policy.conditions.push(["starts-with", "$key", keyStartsWith]);
      this.formData.key = key;
    }

    // set bucket name
  }, {
    key: 'setBucket',
    value: function setBucket(bucket) {
      if (!bucket) {
        throw new _errorsJs2['default']("bucket can not be null");
      }
      this.policy.conditions.push(["eq", "$bucket", bucket]);
      this.formData.bucket = bucket;
    }

    // set Content-Type
  }, {
    key: 'setContentType',
    value: function setContentType(type) {
      if (!type) {
        throw new _errorsJs2['default']("content-type can not be null");
      }
      this.policy.conditions.push(["eq", "$Content-Type", type]);
      this.formData["Content-Type"] = type;
    }
  }]);

  return PostPolicy;
})();

module.exports = exports['default'];
//# sourceMappingURL=minio.js.map
