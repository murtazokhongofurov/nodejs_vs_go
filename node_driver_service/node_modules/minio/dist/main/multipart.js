/*
 * Minio Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _concatStream = require('concat-stream');

var _concatStream2 = _interopRequireDefault(_concatStream);

var _stream = require('stream');

var _stream2 = _interopRequireDefault(_stream);

var _xml = require('xml');

var _xml2 = _interopRequireDefault(_xml);

var _through2 = require('through2');

var _through22 = _interopRequireDefault(_through2);

var _helpersJs = require('./helpers.js');

var _signingJs = require('./signing.js');

var _transformersJs = require('./transformers.js');

var transformers = _interopRequireWildcard(_transformersJs);

var _xmlParsersJs = require('./xml-parsers.js');

var xmlParsers = _interopRequireWildcard(_xmlParsersJs);

var Multipart = (function () {
  function Multipart(params, transport) {
    _classCallCheck(this, Multipart);

    this.params = params;
    this.transport = transport;
  }

  _createClass(Multipart, [{
    key: 'initiateNewMultipartUpload',
    value: function initiateNewMultipartUpload(bucket, key, contentType, cb) {
      var requestParams = {
        host: this.params.host,
        port: this.params.port,
        protocol: this.params.protocol,
        path: '/' + bucket + '/' + (0, _helpersJs.uriResourceEscape)(key) + '?uploads',
        method: 'POST',
        headers: {
          'Content-Type': contentType
        }
      };

      (0, _signingJs.signV4)(requestParams, '', this.params.accessKey, this.params.secretKey);

      var concater = transformers.getConcater();
      var transformer = transformers.getInitiateMultipartTransformer();
      var request = this.transport.request(requestParams, function (response) {
        if (response.statusCode !== 200) {
          var errorTransformer = transformers.getErrorTransformer(response);
          (0, _helpersJs.pipesetup)(response, concater, errorTransformer).on('error', function (e) {
            return cb(e);
          });
          return;
        }
        (0, _helpersJs.pipesetup)(response, concater, transformer).on('error', function (e) {
          return cb(e);
        }).on('data', function (uploadId) {
          return cb(null, uploadId);
        });
      });
      request.end();
    }
  }, {
    key: 'completeMultipartUpload',
    value: function completeMultipartUpload(bucket, key, uploadId, etags, cb) {
      var requestParams = {
        host: this.params.host,
        port: this.params.port,
        protocol: this.params.protocol,
        path: '/' + bucket + '/' + (0, _helpersJs.uriResourceEscape)(key) + '?uploadId=' + uploadId,
        method: 'POST'
      };
      var parts = [];

      etags.forEach(function (element) {
        parts.push({
          Part: [{
            PartNumber: element.part
          }, {
            ETag: element.etag
          }]
        });
      });

      var payloadObject = {
        CompleteMultipartUpload: parts
      },
          payload = (0, _xml2['default'])(payloadObject),
          hash = _crypto2['default'].createHash('sha256');

      hash.update(payload);

      var sha256 = hash.digest('hex').toLowerCase();

      (0, _signingJs.signV4)(requestParams, sha256, this.params.accessKey, this.params.secretKey);

      var concater = transformers.getConcater();
      var transformer = transformers.getCompleteMultipartTransformer();

      var request = this.transport.request(requestParams, function (response) {
        if (response.statusCode !== 200) {
          var errorTransformer = transformers.getErrorTransformer(response);
          (0, _helpersJs.pipesetup)(response, concater, errorTransformer).on('error', function (e) {
            return cb(e);
          });
          return;
        }
        (0, _helpersJs.pipesetup)(response, concater, transformer).on('error', function (e) {
          return cb(e);
        }).on('data', function (result) {
          return cb(null, result.etag);
        });
      });
      request.write(payload);
      request.end();
    }
  }, {
    key: 'listAllParts',
    value: function listAllParts(bucket, key, uploadId, cb) {
      var parts = [];
      var self = this;
      function listNext(marker) {
        self.listParts(bucket, key, uploadId, marker, function (e, result) {
          if (e) {
            cb(e);
            return;
          }
          parts = parts.concat(result.parts);
          if (result.isTruncated) {
            listNext(result.marker);
            return;
          }
          cb(null, parts);
        });
      }
      listNext(0);
    }
  }, {
    key: 'listParts',
    value: function listParts(bucket, key, uploadId, marker, cb) {
      var query = '?';
      if (marker && marker !== 0) {
        query += 'part-number-marker=' + marker + '&';
      }
      query += 'uploadId=' + uploadId;
      var requestParams = {
        host: this.params.host,
        port: this.params.port,
        protocol: this.params.protocol,
        path: '/' + bucket + '/' + (0, _helpersJs.uriResourceEscape)(key) + query,
        method: 'GET'
      };

      (0, _signingJs.signV4)(requestParams, '', this.params.accessKey, this.params.secretKey);
      var concater = transformers.getConcater();
      var transformer = transformers.getListPartsTransformer();
      var req = this.transport.request(requestParams, function (response) {
        if (response.statusCode !== 200) {
          var errorTransformer = transformers.getErrorTransformer(response);
          (0, _helpersJs.pipesetup)(response, concater, errorTransformer).on('error', function (e) {
            return cb(e);
          });
          return;
        }
        (0, _helpersJs.pipesetup)(response, concater, transformer).on('error', function (e) {
          return cb(e);
        }).on('data', function (data) {
          return cb(null, data);
        });
      });
      req.on('error', function (e) {
        return cb(e);
      });
      req.end();
    }
  }, {
    key: 'listIncompleteUploadsOnce',
    value: function listIncompleteUploadsOnce(bucket, prefix, keyMarker, uploadIdMarker, delimiter) {
      var queries = [];
      if (prefix) {
        queries.push('prefix=' + (0, _helpersJs.uriEscape)(prefix));
      }
      if (keyMarker) {
        keyMarker = (0, _helpersJs.uriEscape)(keyMarker);
        queries.push('key-marker=' + keyMarker);
      }
      if (uploadIdMarker) {
        queries.push('upload-id-marker=' + uploadIdMarker);
      }
      if (delimiter) {
        queries.push('delimiter=' + (0, _helpersJs.uriEscape)(delimiter));
      }
      var maxUploads = 1000;
      queries.push('max-uploads=' + maxUploads);
      queries.sort();
      queries.unshift('uploads');
      var query = '';
      if (queries.length > 0) {
        query = '?' + queries.join('&');
      }
      var requestParams = {
        host: this.params.host,
        port: this.params.port,
        path: '/' + bucket + query,
        method: 'GET'
      };
      (0, _signingJs.signV4)(requestParams, '', this.params.accessKey, this.params.secretKey);

      var transformer = transformers.getListMultipartTransformer();
      var dummyTransformer = transformers.getDummyTransformer();
      var concater = transformers.getConcater();

      var req = this.transport.request(requestParams, function (response) {
        if (response.statusCode !== 200) {
          var errorTransformer = transformers.getErrorTransformer(response);
          (0, _helpersJs.pipesetup)(response, concater, errorTransformer, dummyTransformer);
          return;
        }
        (0, _helpersJs.pipesetup)(response, concater, transformer, dummyTransformer);
      });
      req.on('error', function (e) {
        return dummyTransformer.emit('error', e);
      });
      req.end();
      return dummyTransformer;
    }
  }, {
    key: 'findUploadId',
    value: function findUploadId(bucket, key, cb) {
      var self = this;
      function listNext(keyMarker, uploadIdMarker) {
        self.listIncompleteUploadsOnce(bucket, key, keyMarker, uploadIdMarker).on('error', function (e) {
          return cb(e);
        }).on('data', function (result) {
          var keyFound = false;
          result.uploads.forEach(function (upload) {
            if (upload.key === key) {
              cb(null, upload.uploadId);
              keyFound = true;
            }
          });
          if (keyFound) {
            return;
          }
          if (result.isTruncated) {
            listNext(result.nextKeyMarker, result.nextUploadIdMarker);
            return;
          }
          cb(null, undefined);
        });
      }
      listNext();
    }
  }, {
    key: 'chunkUploader',
    value: function chunkUploader(bucket, key, contentType, uploadId, partsArray) {
      var partsDone = [];
      var self = this;
      var partNumber = 1;

      // convert array to object to make things easy
      var parts = partsArray.reduce(function (acc, item) {
        if (!acc[item.part]) {
          acc[item.part] = item;
        }
        return acc;
      }, {});

      return _through22['default'].obj(function (chunk, enc, cb) {
        var part = parts[partNumber];
        if (part) {
          var hash = _crypto2['default'].createHash('md5');
          hash.update(chunk);
          var md5 = hash.digest('hex').toLowerCase();
          if (md5 === part.etag) {
            //md5 matches, chunk already uploaded
            partsDone.push({ part: part.part, etag: part.etag });
            partNumber++;
            return cb();
          }
          // md5 doesn't match, upload again
        }
        self.doPutObject(bucket, key, contentType, uploadId, partNumber, chunk, function (e, etag) {
          if (e) {
            partNumber++;
            return cb(e);
          }
          var part = {
            part: partNumber,
            etag: etag
          };
          partsDone.push(part);
          partNumber++;
          cb();
        });
      }, function (cb) {
        this.push(partsDone);
        this.push(null);
        cb();
      });
    }
  }, {
    key: 'doPutObject',
    value: function doPutObject(bucket, key, contentType, uploadId, part, data, cb) {
      var query = '';
      if (part) {
        query = '?partNumber=' + part + '&uploadId=' + uploadId;
      }
      if (contentType === null || contentType === '') {
        contentType = 'application/octet-stream';
      }

      var hash256 = _crypto2['default'].createHash('sha256');
      var hashMD5 = _crypto2['default'].createHash('md5');

      hash256.update(data);
      hashMD5.update(data);

      var sha256 = hash256.digest('hex').toLowerCase(),
          md5 = hashMD5.digest('base64'),
          requestParams = {
        host: this.params.host,
        port: this.params.port,
        protocol: this.params.protocol,
        path: '/' + bucket + '/' + (0, _helpersJs.uriResourceEscape)(key) + query,
        method: 'PUT',
        headers: {
          'Content-Length': data.length,
          'Content-Type': contentType,
          'Content-MD5': md5
        }
      };

      (0, _signingJs.signV4)(requestParams, sha256, this.params.accessKey, this.params.secretKey);
      var req = this.transport.request(requestParams, function (response) {
        if (response.statusCode !== 200) {
          var concater = transformers.getConcater();
          var errorTransformer = transformers.getErrorTransformer(response);
          (0, _helpersJs.pipesetup)(response, concater, errorTransformer).on('error', function (e) {
            return cb(e);
          });
          return;
        }
        var etag = response.headers.etag;
        if (etag) {
          etag = etag.replace(/^\"/, '').replace(/\"$/, '');
        }
        cb(null, etag);
      });
      req.on('error', function (e) {
        return cb(e);
      });
      req.write(data);
      req.end();
    }
  }]);

  return Multipart;
})();

exports['default'] = Multipart;
module.exports = exports['default'];
//# sourceMappingURL=multipart.js.map
